\chapter{Implementation}

\section{Introduction}
This chapter will explore the final implementation of the proposed system by giving an overview of the final system as well as discussing the languages and libraries used. It will also highlight any challenges that were encountered during the development process. Furthermore, it will discuss the comparison system used in the final usability evaluation and the maintainability of each of the systems.

\section{System Overview}
As shown in Figure \ref{fig:componentDiagram}, the final system was separated into two individual systems: a scripting tool and a web application. The scripting tool generates the required files for the web application based on information from Bioschemas and Schema.org. The web application then uses these files to display a form and additional information to allow users to markup Bioschemas profiles.

Separating the file generation from the web application allowed the load times to be kept as low as possible. By generating the files separately and having the web application fetch the generated files, it removes the time needed to generate the files each time the web application is loaded.


\newpage
\vspace*{2em}
\begin{figure}[!h]
 \centering\includegraphics[scale=0.6]{images/ComponentDiagram.png}
   \caption{Component Diagram}
   \label{fig:componentDiagram}
\end{figure}

\newpage
\section{Scripting Tool}\label{sec:scriptingtool}

\subsection{Choice of Language}
After developing the initial prototype to help gather requirements and ensuring I was satisfied with the approach to utilise JSON-Schema to generate the form. The next step was to begin developing a tool that takes the declarative descriptions of the Bioschemas profiles and generates the required files (JSON and JSON-Schema).

To implement this tool, I had two different options available. I could either extend the Bioschemas GoWeb tool which generates the declarative description of the Bioschemas Profiles or create a separate tool in Python that takes the output of GoWeb and further processes it.

\subsubsection{Bioschemas GoWeb}
Go\footnote{\url{https://golang.org} (accessed 28/02/2019)}, also known as GoLang, is an open source language developed by Google that is similarly modelled after C \cite{goLang} and is also considered to be lightly object-orientated \cite{goObject}. While I do not have any experience with this language specifically, I have a lot of experience working with object-orientated languages but have very limited experience with C. 

Bioschemas GoWeb\footnote{\url{https://github.com/BioSchemas/bioschemas-goweb} (accessed 28/02/2019)}, developed in Go, is a tool that generates a declarative description of the Bioschemas profiles. The declarative descriptions that it generates is a human friendly but machine readable format called YAML\footnote{\url{https://yaml.org/} (accessed 28/02/2019)}. To generate the YAML, the tool uses CSVs which contains information about the Bioschemas profiles. To aid the webmasters in creating the CSVs, a Google Sheets template and detailed instructions are provided.

This is a valid option for our scripting tool as we could extend Bioschemas GoWeb by taking the YAML it produces and then generating the files needed directly from it. Furthermore, by generating the files directly from the YAML, it mitigates the need to retrieve the generated YAML from the Bioschemas Github\footnote{\url{https://github.com/BioSchemas/bioschemas.github.io} (accessed 28/02/2019)}.

\subsubsection{Python Tool}
Python\footnote{\url{https://python.org} (accessed 28/02/2019)} is a object-orientated language, high-level programming language that is often used for rapid prototyping. Through university coursework and personal projects I have a lot of experience with this language as well as other object-orientated languages. 

This is a valid option as the YAML generated by the GoWeb tool for the Bioschemas profiles is available through the Bioschemas Github. In this case we would be able to retrieve the YAML directly from the Github and then further process the YAML into the desired files, instead of processing the CSV's directly to generate the YAML first like in the GoWeb tool.

\subsubsection{Selection}
While the Bioschemas GoWeb tool is a good starting point in developing the scripting tool, I can not neglect my experience and knowledge with Python and object-orientated programming. As time management is critical in this project with Python being utilised in rapid prototype development and having a more extensive selection of libraries, the tool will be written in Python.

\subsection{Declarative Description Processing}\label{sec:declarative}
The first stage of generating the required files for the web application was retrieving information about and surrounding the Bioschemas profiles and converting it into a usable format. As the information is collected from multiple sources (Shown in Figure \ref{fig:componentDiagram}), two methods of retrieval and conversion were used. 

For the first method, the information about the Bioschemas profiles were located on the Bioschemas Github and were in the YAML format. Using Python library Requests\footnote{\url{http://docs.python-requests.org/en/master/} (accessed 28/02/2019)} the YAML was retrieved using HTTP GET requests. The Python library PyYAML\footnote{\url{https://pyyaml.org/} (accessed 28/02/2019)} was then used to convert the YAML into a Python object to be further processed. Shown in Appendix \ref{sec:geneYAML} is an example of the YAML retrieved for the Bioschemas profile Gene (v0.4)\footnote{\url{https://bioschemas.org/specifications/Gene/} (accessed 28/02/2019)} and the resulting Python object displayed as JSON is shown in Appendix \ref{sec:genePythonObject}.

\newpage
The second method was used to fetch additional information about Bioschemas and Schema.org types. Similar to the first method, this was achieved  using the Request Python library to perform HTTP GET requests to retrieve the information in the format of JSON-LD. As JSON-LD only adds specific key pair values in comparison to JSON, I was able to use the Python library JSON\footnote{\url{https://docs.python.org/2/library/json.html} (accessed 28/02/2019)} to convert the JSON-LD into a Python object to be further processed. Shown in Appendix \ref{sec:BioChemJSONLD} is the JSON-LD for the Bioschemas type BioChemEntity\footnote{\url{http://bio.sdo-bioschemas-227516.appspot.com/BioChemEntity} (accessed 05/04/2019)}.

Once the methods of retrieving the information was figured out, the next stage of the process was to generate the JSON-Schema\footnote{\url{https://json-schema.org/} (accessed 05/04/2019)} used to display the form on the web application. To create the JSON-Schema, I was able to create a Python dictionary of key value pairs and then using the JSON library I was able to output the dictionary as JSON-Schema. During this stage, I encountered three major issues that are discussed in Section \ref{sec:issues}. Through using the iterative development process and help from my supervisor Dr. Alasdair Gray, I was able to work through these issues to create the JSON-Schema describing the Bioschemas profiles. Shown in Appendix \ref{sec:geneJSONSchema} is an example of the JSON-Schema generated for the Bioschemas Gene (v0.4)\footnote{\url{http://bioschemas.org/specifications/Gene/} (accessed 02/03/2019)} profile.

The final stage of the process was to generate JSON that is used to display additional information (examples and controlled vocabulary) along side the form on the web application. This used the same method as creating the JSON-Schema, by creating a Python dictionary of key value pairs and then utilising the Python library JSON to output the dictionary as JSON. Shown in Appendix \ref{sec:geneAdditionalInformation} is example of the generated JSON for the Bioschemas Gene (v0.4) profile.

To summarise, the scripting tool generates two files for each Bioschemas profile: A JSON-Schema file that is used by the JavaScript library JSON-Editor (See Section \ref{sec:jsoneditor}) to display a form that the user can use to markup Bioschemas profiles and a JSON file that contains the controlled vocabularies and examples of the profiles properties to be displayed along side the form (See Section \ref{sec:additionalinformation}).


\newpage
{\setstretch{1.85}
\section{Web Application}\label{sec:webapplication}
The web application consists of an Apache Web Server\footnote{\url{https://httpd.apache.org/} (accessed 12/03/2019)} (Version 2.2.15), containing the front-end user interface as well as JavaScript scripts and libraries for client-side processing. The web application retrieves the generated files from the scripting tool (See Section \ref{sec:declarative}) that are stored on the Apache Web Server and using a multitude of libraries (See Section \ref{sec:libraries}) provides the desired functionality of the proposed system. 

\subsection{User Interface Design}\label{sec:userInterface}
The user interface provides an easy and intuitive way for users to select, provide information and generate the markup for a Bioschemas profile. It was developed using HTML5, CSS3 and Bootstrap 4. I used Bootstrap\footnote{\url{https://getbootstrap.com/} (accessed 12/03/2019)} as a front-end web framework to handle the layout, styling and fonts of the HTML elements that are displayed to the user. Bootstrap also supports the latest, stable releases of all major browsers and platforms, which forms part of the system requirements (Non-Functional Requirement NFR3: The system should be accessible through the top internet browsers: Google Chrome, Mozilla Firefox and Apple Safari.).

\subsubsection*{Select Profile}
The Select Profile section is designed to allow users to select which Bioschemas profile they would like to generate a markup for through a drop-down list, shown in Figure \ref{fig:selectProfle}. Unfortunately, as the profiles are added to the drop-down list asynchronously, the resulting drop-down list is not alphabetically ordered, possibly adding time for a user to find their desired profile. The "Generate Form" button then displays the form for the Bioschemas profile they selected.\newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.65]{images/system/generateForm.PNG}
   \caption{Select Profile}
   \label{fig:selectProfle}
\end{figure}

}

\newpage
\subsubsection*{Profile Form}
The Profile Form section is designed to allow the user to provide information to markup a Bioschemas profile they previously selected, shown in Figure \ref{fig:geneProfile}. The page is designed as two parts: the left hand side displaying the form for users to provide the information with the right hand side providing additional information like examples and controlled vocabularies. \newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.7]{images/system/geneForm.PNG}
   \caption{Bioschemas Profile Gene Form}
   \label{fig:geneProfile}
\end{figure}

\newpage
The form is displayed using the JSON-Editor JavaScript library, which will be discussed in Section \ref{sec:jsoneditor} and is styled using Boostrap 4. By default it displays the Minimum required properties of the Bioschemas Profile. To add the Recommended and Optional properties to the form, select the "Additional Properties" button, shown in Figure \ref{fig:additionalProperties} and then select the check box next to the desired properties.\newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.7]{images/system/geneAdditionalProperties.PNG}
   \caption{Bioschemas Profile Gene Additional Properties}
   \label{fig:additionalProperties}
\end{figure} 

For Properties that have a cardinality of many, items can be added through the "Add item" button shown in Figure \ref{fig:arrayAdd}. Once an item has been added, the type of item can then be selected through the drop-down, the example shown in \ref{fig:arrayDelete} is of type URL\footnote{\url{https://schema.org/URL} (accessed 12/03/2019)}. To remove an item, select the "Delete item" button and then confirm through the browser pop-up.

\begin{figure}[!h]
 \centering\includegraphics[scale=0.8]{images/system/geneAdd.PNG}
   \caption{Bioschemas Profile Gene Encodes Array}
   \label{fig:arrayAdd}
\end{figure}

\begin{figure}[!h]
 \centering\includegraphics[scale=0.8]{images/system/geneRemove.PNG}
   \caption{Bioschemas Profile Gene Encodes Array Item}
   \label{fig:arrayDelete}
\end{figure}

{\setstretch{1.65}
\newpage
The Property Tips are displayed using a custom JavaScript script, see Section \ref{sec:additionalinformation} and is styled using Bootstrap 4. I decided to split the additional information into three collapsible sections, by marginality of the properties (Minimum, Recommended and Optional). Taking inspiration from the Bioschemas website\footnote{\url{https://bioschemas.org/} (accessed 07/04/2019)}, I decided that the best way to display the examples to the user was to use a modal pop-up, shown in Figure \ref{fig:geneEncodesExample}. The decision to separate and nest the additional information was taken to reduce the information overload to the user and to hopefully not confuse them straight away.\newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.42]{images/system/propertyExample.PNG}
   \caption{Bioschemas Profile Gene Encodes Example}
   \label{fig:geneEncodesExample}
\end{figure}

\subsubsection*{Generated Markup}
The Generated Markup section shows the user the generated markup based on the Bioschemas profile they selected and the information they provided, shown in Figure \ref{fig:generatedMarkup}. The web application generates three formats of machine-readable data: JSON-LD, Microdata and RDFa, which can be accessed through the appropriate navigation tabs. The "Download" button also allows the user to download the generated markup (which ever format is currently being displayed) into a HTML file.\newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.38]{images/system/GeneratedData.PNG}
   \caption{Bioschemas Profile Markup DataCatalog Example}
   \label{fig:generatedMarkup}
\end{figure}

}

\newpage
\subsection{Scripts, Libraries and APIs}\label{sec:libraries}

\subsubsection{JSON-Editor} \label{sec:jsoneditor}
To allow users to markup Bioschemas profiles, JSON-Schema\footnote{\url{https://json-schema.org/} (accessed 07/04/2019)} was used to dynamically generate forms using a JavaScript library. The JSON-Schema is generated by the scripting tool (See Section \ref{sec:scriptingtool}) that is then used by a library to generate and display a HTML form. Through the iterative development cycle, three libraries were used as requirements and limitations of the different libraries came to light. I will now discuss the two libraries used for the prototype system in comparison to the library used in the final system.

The first iteration of the prototype was built using the JavaScript library SchemaForm.io\footnote{\url{http://www.schemaform.io/} (accessed 03/11/2018)}. It was quickly discovered that this library was inadequate for the system due to not supporting arrays of multiple types. Discussed in Section \ref{ch:prototyping}, properties that have a cardinality of many and multiple expected types can produce arrays of multiple types leading to an incompatibility between the library and system requirements. Listing \ref{lst:multipleTypesArray} is an example markup of the Bioschemas profile DataCatalog\footnote{\url{https://bioschemas.org/specifications/DataCatalog/} (accessed 07/04/2019)} in which the provider property has an array of multiple types (Organization\footnote{\url{https://schema.org/Organization} (accessed 07/04/2019)} and Person\footnote{\url{https://schema.org/Person} (accessed 07/04/2019)}) which ultimately could not be produced by this library.

\vspace{1.5em}

{\setstretch{1.0}
\begin{center}
\begin{lstlisting}[
caption=DataCatalog Example Array of Multiple Types,
captionpos=b,
label={lst:multipleTypesArray},
xleftmargin=0pt,
xrightmargin=10pt,
language=HTML,
showstringspaces=false]
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "DataCatalog",
    "provider": [
        {
            "@type": "Organization",
            "name": "The International Union of Basic and Clinical Pharmacology",
            "url": "http://www.iuphar.org/"
        },
        {
            "@type": "Person",
            "givenName": "John",
            "familyName": "Doe"
            "url": "http://www.johndoe.com"
        }
    ]
}
</script>
\end{lstlisting}  
\end{center}
}

\newpage
{\setstretch{1.85}
The second iteration of the prototype was built using the JavaScript library JSON-Forms\footnote{\url{https://github.com/brutusin/json-forms} (accessed 03/11/2018)}. In comparison to the first library used, this library was able to support arrays of multiple types but did not support the requirement of recursion. As previously discussed in Section \ref{ch:prototyping}, that in order to generate markup based on the Bioschemas profiles, the form should be able to handle recursive property types. This is due to properties in Schema.org types having the ability to contain themselves as an expected type.

The JSON-Schema specification has the ability to define schemas that can reused and combined elsewhere in the schema \cite{jsonSchemaComplex}. Once a schema has been defined it can then be referenced using the keyword \texttt{\$ref} where the value is a Universal Resource Identifier (URI) of the schema. Shown in Listing \ref{lst:dataCatalogRecursion2}, the PropertyValue schema is defined and is then is referenced within the DataCatalog schema using a local URI. The ability to reference schema allows schemas to be self-referential and can therefore create recursive schemas \cite{jsonSchemaComplex}. Shown in Listing \ref{lst:dataCatalogRecursion2} is an example of a recursive schema in which the schema PropertyValue can contain itself as a value.

Although JSON-Schema specification supports recursive schemas which in turn can handle recursive Schema.org property types that is needed to support the markup of Bioschemas profiles, the library JSON-Forms was unable to support this specification and therefore unable to support the markup of Bioschemas profiles.
}
\lstset{
    string=[s]{"}{"},
    stringstyle=\bfseries,
    comment=[l]{:},
    commentstyle=\color{black},
}


{\setstretch{0.9}
\begin{center}
\begin{lstlisting}[
caption=DataCatalog Recursive Schema Example,
captionpos=b,
label={lst:dataCatalogRecursion2},
showstringspaces=false,
basicstyle=\small]

"schema":{
    "title":"DataCatalog",
    "type":"object",
    "properties":{
        "identifier":{
            "title":"identifier",
            "oneOf":[
                {
                    "$ref":"#/definitions/PropertyValue"
                }
            ]
        }
    },
    "definitions":{
        "PropertyValue":{
             "title":"PropertyValue",
             "type":"object",
             "properties":{
                "valueReference":{
                    "title":"valueReference",
                    "oneOf":[
                        {
                            "$ref":"#/definitions/PropertyValue"
                        }
                    ]
                }
             }
        }
    }
}

\end{lstlisting}  
\end{center}
}


\newpage
The final system was built using the JavaScript library JSON-Editor\footnote{\url{https://github.com/json-editor/json-editor} (accessed 16/03/2019)}. The following list of features are supported by JSON-Editor and highlights how they were utilised to allow users to markup Bioschemas profiles:

{\setstretch{1.5}
\begin{description}
  \item[Descriptions: ]
  Supports the creation of markup by displaying a detailed description of each property to the user.
  \item[Arrays: ]
  Supports the creation of arrays allowing properties that have a cardinality of many to be marked up. 
  \item[One Of: ]
  Supports the ability for users to choose which expected type for a property to markup.
  \item[Recursion: ]
  Supports the markup of Schema.org types where properties have a recursive expected type.
  \item[Required Properties: ]
  Supports marginality of properties by requiring minimum properties to be marked up.
  \item[Property Ordering: ]
  Supports ordering of form inputs / properties to display the most relevant properties first. i.e Minimum then Recommended then Optional properties.
  \item[Definitions \& References: ]
  Supports the ability to create efficient JSON-Schema through the use definitions and references of schemas.
  \item[Default \& Hidden Properties: ]
  Supports the creation of JSON-LD by providing JSON-LD key value pairs like \texttt{@type} and \texttt{@context} without the unnecessary form inputs being displayed to the user.
\end{description}
}

\subsubsection{Additional Information Panel} \label{sec:additionalinformation}
A custom JavaScript script was used to display additional information (examples and controlled vocabulary) to the user to help markup Bioschemas profiles. Originally, I had planned to use a JavaScript library like Tabular\footnote{\url{https://github.com/json-editor/json-editor} (accessed 16/03/2019)} to display the JSON file containing the additional information in a table. As previously mentioned in Section \ref{sec:userInterface}, I decided that displaying all the information at once in a table could overwhelm the user. Therefore, I created a custom script to display the information in a controlled way which can be seen in Figure \ref{fig:geneProfile}.

{\setstretch{1.9}
\subsubsection{RDF Translator API}
The RDF Translator API\footnote{\url{https://rdf-translator.appspot.com/} (accessed 16/03/2019)} was used to convert the generated JSON-LD into additional machine-readable formats for the web: RDFa and Microdata. The client-side makes a AJAX request containing the JSON-LD that is to be converted to the desired formats. The resulting data is returned in either RDFa or Microdata, dependant on the format specified in the request URL. 

As RDFa and Microdata use HTML as a basis to add machine-readable data to the web, the data returned is in the HTML format. To display the HTML to the user, it first needs to be escaped so that it will be displayed correctly on the web page. This was achieved by using jQuery's text\footnote{\url{http://api.jquery.com/text/} (accessed 16/03/2019)} function to set the content of the selected element to the HTML as it automatically escapes the necessary characters for the HTML to be displayed.

\subsubsection{Bootbox.js}
Bootbox.js\footnote{\url{https://github.com/makeusabrew/bootbox} (accessed 16/03/2019)} was used to programmatically create and display Bootstrap pop-up modals to provide the user with example markups, shown in Figure \ref{fig:geneEncodesExample}. Without the library, a system would have to be implemented to create, manage and remove any of the required DOM elements or JavaScript event handlers to produce the pop-up modals which can be difficult and time consuming to implement. Due to the predicted difficulty in implementing the same functionality provided by Bootbox.js and the time constraints associated with the project, Bootbox.js was used to produce the desired functionality.


\subsubsection{Download.js}
Download.js\footnote{\url{http://danml.com/download.html} (accessed 16/03/2019)} was used to allow the user to download the generated markup of their selected Bioschemas profile. An additional library was needed as the W3C standard File API: Writer that can be used to store files on a client's machine is currently only supported by the browser Google Chrome \cite{fileAPI}\cite{fileAPISupport}. This issue was not inline with the requirements outlined at the beginning of the project (Non-Functional Requirement NFR3: The system should be accessible through the top internet browsers: Google Chrome, Mozilla Firefox and Apple Safari.), so an additional library was used to provide the desired functionality.
}

\subsection{Hosting the Web Application}
The implementation began on my personal machine, with the intention of deploying the web application on a publicly accessible web server. The decision to make it publicly accessible was to enable the Bioschemas community during meetings and workshops to provide feedback (See Section \ref{sec:prototyUsability}) on the system whilst the system was still in development, without having Dr. Alasdair Gray host the web application himself.

The web application built is a HTML/JavaScript application and because of this it can be deployed on any standard web server. For this reason, I was able to host the application on the the Heriot-Watt MACS Student/Development web server. The choice to use this server was made as a student at Heriot-Watt University I was already given access and along with the ability to host the application on any web server no additional setup was required. 


\section{Implementation Challenges}\label{sec:issues}
As the system relies heavily on the generation of JSON-Schema and an open-source library to utilise the generated JSON-Schema, it was inevitable that there would a few issues surrounding this area. The key use and generation issues encountered during development with JSON-Schema were:

\begin{enumerate}
  \item Bioschemas profile data format inconsistencies.
   \item JSON-Editor unable to handle documented features.
  \item JSON-Editor unable to handle large JSON-Schema.
\end{enumerate}


\subsection{Issue 1: Data Format Inconsistencies}
%Conjoined lists of properties
This issue was caused by the inconsistent formatting of data within the declarative descriptions of the Bioschemas profiles. As Bioschemas is currently in a stage where they are rapidly evolving and refining their profiles, older formats of data still exists in a number of current profiles. 

Each Bioschemas profiles has a list of properties in which each property has a list of expected types. Once the declarative description of a profile has been converted from YAML to JSON to be further processed, each property should contain an array of expected types. Although, in some cases the list of expected types are conjoined into a singular string making it difficult to process. For example in Bioschemas profile ProteinAnnotation (v0.4)\footnote{\url{http://bioschemas.org/specifications/ProteinAnnotation/} (accessed 01/03/2019)}, the expected output of expected types for the property location is shown in Listing \ref{lst:expectedOutput}, while the actual output is shown in Listing \ref{lst:actualOutput}.


\newpage
{\setstretch{1.75}
\lstset{
    string=[s]{"}{"},
    stringstyle=\color{black},
    comment=[l]{:},
    commentstyle=\color{black},
}
\begin{lstlisting}[
caption=Expected Output,
captionpos=b,
label={lst:expectedOutput},
xleftmargin=60pt,
xrightmargin=10pt,
language=html]
["Place","PostalAddress","PropertyValue","Text", "URL"]
\end{lstlisting}

\begin{center}
\begin{lstlisting}[
caption=Actual Output,
captionpos=b,
label={lst:actualOutput},
xleftmargin=60pt,
xrightmargin=10pt,
showstringspaces=false]
["Place orPostalAddress orPropertyValue orText orURL"]
\end{lstlisting}  
\end{center}

To solve this issue, the singular string was split into an array of individual types and the additional "or" before each type was removed, keeping the format consistent with the expected output. This kept the format of the expected types consistent across the different Bioschemas profiles and ready to be further processed.

\subsection{Issue 2: JSON-Editor Documentation}
The inconsistency in the documentation of the JavaScript library JSON-Editor in comparison to what could be implemented with the library caused two issues. Both issues relate to the libraries documentation stating that "it has full support for JSON-Schema Version 3 and 4" \cite{jsonEditor}. Meaning the library should fully support the use of keyword \texttt{oneOf} specified in JSON-Schema version 4\footnote{\url{https://tools.ietf.org/html/draft-fge-json-schema-validation-00} (accessed 01/03/2019)}, although this seems not to be the case.

% Date and datetime in one of
The first issue encountered was due specifying the formats of strings. By specifying the format of a string, the form input generated only accepts the format specified. For example, specifying the format email will only allow valid emails to be accepted. According to the documentation, JSON-Editor supports the necessary formats to allow users to enter the necessary data types specified by Schema.org DataTypes\footnote{\url{https://schema.org/DataType} (accessed 01/03/2019)}. Although when formats date or date-time are used in conjunction with the keyword \texttt{oneOf} (Example shown in Listing \ref{lst:stringFormatIssue}) it leads to an error in which the form input would not be displayed to the user. \newline

}
\lstset{
    string=[s]{"}{"},
    stringstyle=\bfseries,
    comment=[l]{:},
    commentstyle=\color{black},
}

{\setstretch{0.9}
\begin{center}
\begin{lstlisting}[
caption=Example Schema String Format Issue,
captionpos=b,
label={lst:stringFormatIssue},
showstringspaces=false,
basicstyle=\small]
"schema":{
    "title": "String Format Issue",
    "oneOf": [
        {
          "title": "Date",
          "type": "string",
          "format": "date"
        },
        {
          "title": "Date-Time",
          "type": "string",
          "format": "date-time"
        }
    ]
}
\end{lstlisting}  
\end{center}
}

To handle this issue, I decided that the user must be able to provide data for these data types as this issue is detrimental to the systems functionality. Until a solution is found, the offending formats were removed from the JSON-Schema to allow the system to function correctly. This compromise unfortunately leads to the possibility that user can now provide incorrect formats of date and date-time when creating a markup for a profile.


% recursive one of arrays
The second issue encountered was due to recursive definitions. As previously discussed in Section \ref{sec:jsoneditor}, the JSON-Schema specification supports definitions of a recursive nature. JSON-Editor supports these recursive definitions, although when used in conjunction with the \texttt{oneOf} specification (Example shown in Listing \ref{lst:dataCatalogRecursion} ) it leads to the recursive form inputs not being displayed to the user.\newline

{\setstretch{0.9}
\begin{center}
\begin{lstlisting}[
caption=Example Schema Recursion Issue,
captionpos=b,
label={lst:dataCatalogRecursion},
showstringspaces=false,
basicstyle=\small]
"schema":{
    "title": "String Format Issue",
    "$ref": "#/definitions/recursion",
    "definitions":{
        "recursion":{
            "title":"recursion",
            "oneOf": [
                {
                    "title": "example",
                    "$ref": "#/definitions/recursion"
                }
            ]
        }
    }
}
\end{lstlisting}  
\end{center}
}

This issue was fortunately negated as a result of solving the issue of JSON-Editor being unable to handle large JSON-Schema. Discussed in Section \ref{sec:largeSchema}, to reduce the size of the JSON-Schema, nested Schema.org types were removed and in place an International Resource Identifier (IRI) was given. As a result of this solution, no recursive definitions were used and so no solution was needed for this issue.


To contribute to the open-source community and help the development of JSON-Editor, I fed back these issue to the developers by submitting the issues on their Github repository\footnote{\url{https://github.com/json-editor/json-editor/issues} (accessed 02/03/2019)}. To help the developers in understanding the issues I provided a detailed explanation of the errors and gave examples of the error prone JSON-Schemas. Issue 323\footnote{\url{https://github.com/json-editor/json-editor/issues/323}(accessed 02/03/2019)} was submitted in relation to the string format issue and  Issue 248\footnote{\url{https://github.com/json-editor/json-editor/issues/248} (accessed 02/03/2019)} was submitted in relation to the issue of recursion.

\newpage
\subsection{Issue 3: Large JSON-Schema}\label{sec:largeSchema}
This issue was due to the JavaScript library JSON-Editor being unable to handle JSON-Schemas of a large size. The large size of the JSON-Schema comes from the extensive number of types and properties provided by the Schema.org vocabulary. For example, the Bioschemas profile DataCatalog (v0.1)\footnote{\url{http://bioschemas.org/specifications/DataCatalog/} (accessed 02/03/2019)} contains the property called identifier, where the expected types are: PropertyValue\footnote{\url{https://schema.org/PropertyValue} (accessed 02/03/2019)}, Text\footnote{\url{https://schema.org/Text} (accessed 02/03/2019)} or URL\footnote{\url{https://schema.org/URL} (accessed 02/03/2019)}. Where PropertyValue has 20 properties where the expected types are 12 additional Schema.org types. As Schema.org types can reference other types, the overall size of the JSON-Schema can grow exponentially, thus becoming unusable by JSON-Editor.


To allow the JSON-Schema to work with JSON-Editor, a compromise needed to be made to limit the overall size. We decided that instead of nesting Schema.org types (Example shown in Listing \ref{lst:markupNested}) the JSON-LD object for the type would be externally referenced through an Internationalised Resource Identifier (Example shown in Listing \ref{lst:markupIRI}). This dramatically reduced the size of the JSON-Schema allowing it to work with JSON-Editor. Unfortunately this compromise stops the user from being able to markup Schema.org types through the web application and instead having to create, host and reference the markup for the Schema.org types externally. \newline


\lstset{
    string=[s]{"}{"},
    stringstyle=\color{black},
    comment=[l]{:},
    commentstyle=\color{black},
}
{\setstretch{1.4}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Example Markup Nested, captionpos=b,language=html,showstringspaces=false,basicstyle=\footnotesize,label={lst:markupNested}]{Name}
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "DataCatalog",
     "provider": {
        "@type": "Person",
        "givenName": "John",
        "familyName": "Doe",
        "gender": "Male",
        "birthDate": "01/01/1970"
    }
}
</script>
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Example Markup IRI, captionpos=b,language=html,showstringspaces=false,basicstyle=\footnotesize,label={lst:markupIRI}]{Name}
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "DataCatalog",
    "provider": {
        "@type": "Person",
        "@id": "http://www.example.com/JohnDoe"
    }
}
</script>
\end{lstlisting}
\end{minipage}
}

\newpage
\section{Comparison System}\label{sec:comparisonsystem}
The final usability evaluation (See Section \ref{sec:finalUsability}) consisted of comparing the developed system against a second similar system. The system that was chosen for comparison was Kaizen, see Section \ref{sec:kaizen}. As Kaizen is a Google Sheets template it can be easily modified, making it the best choice for the comparison system as it can customised to suit the needs of the evaluation.\newline

\begin{figure}[!h]
 \centering\includegraphics[scale=0.13]{images/system/BioschemasKaizen.PNG}
   \caption{Comparison System}
   \label{fig:comparisonSystem}
\end{figure}


The usability evaluation consisted of participants completing a set of three tasks with the comparison system, therefore it only needed to support the ability to perform these tasks. This lead to participants only being able to markup the DataCatalog  (v0.1)\footnote{\url{http://bioschemas.org/specifications/DataCatalog/} (accessed 02/03/2019)} and Gene (v0.4)\footnote{\url{http://bioschemas.org/specifications/Gene/} (accessed 02/03/2019)} profiles as these were the only profiles needed for the tasks. Although only DataCatalog and Gene were needed, dummy tabs for other profiles were created to keep the system inline with what the final system would be like to use. As Kaizen provides no additional information like descriptions and controlled vocabularies to the user, I took the approach of directing the user to an external source (Bioschemas Website\footnote{\url{http://bioschemas.org/specifications/} (accessed 02/03/2019)}) for this information. The final modified version of the comparison system can be seen in Figure \ref{fig:comparisonSystem}. 
 

\newpage
\section{Maintainability}
After the implementation of both systems, main and comparison, the maintainability of each system was compared in order to see how easy each system was to keep up to date with the latest Bioschemas profiles.

To update the main system to the latest Bioschemas profiles, the webmaster would simply have to re-run the scripting tool (See Section \ref{sec:scriptingtool}) to retrieve the updated files. Once the updated files have been generated the webmaster would then replace the files located on the web server with the newly generated files. Once the files have been replaced, the system will automatically be ready to use with the latest Bioschemas profiles.

As the main system uses a multitude of libraries (See Section \ref{sec:libraries}), the stability of these libraries are a key concern for the maintainability of the system. Libraries JSON-Editor and Bootbox.js see regular updates and fixes and as a result only stable releases are published. However, Download.js has not received any updates in over 10 months. This is a cause for concern as browsers are updated regularly which could lead to the library becoming unusable in the near future.

To update the comparison system to the latest Bioschemas profiles, the webmasters would have to manually check and update each profile as there is currently no automated way of doing so. Additionally, as users create a local copy of the Google Sheet template to use, to receive the latest Bioschemas profiles the users have to check that they are using the latest version and download the newest version if available to keep up to date.


\section{Summary}
Although there were a few issues surrounding the generation and use of the JSON-Schema, the core functionality of the proposed system was successfully developed. A user can select which Bioschemas profile they wish to generate markup for, then provide the data using the form with the help of descriptions, controlled vocabularies and examples. Once the form is filled out they can then generate JSON-LD, Microdata or RDFa to use on their web page. Furthermore, a second comparison system was implemented for the final usability evaluation and the maintainability of each of the system was compared.